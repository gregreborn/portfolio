import ipaddress
import os
import platform
import subprocess
import logging

# Configure logging
logging.basicConfig(
    filename="firewall.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

def log_action(action, ip, protocol, status, details=""):
    """Log the action performed on the firewall."""
    logging.info(f"{action.upper()} - IP: {ip}, Protocol: {protocol}, Status: {status}, Details: {details}")

def test_connectivity(ip):
    """Test if the IP address is reachable using ping."""
    try:
        os_type = platform.system()
        if os_type == "Windows":
            command = f"ping -n 1 {ip}"
        else:
            command = f"ping -c 1 {ip}"

        result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return result.returncode == 0
    except Exception as e:
        print(f"Error testing connectivity for IP {ip}: {e}")
        return False
    
def rule_exists(ip, action, protocol="any"):
    """Check if a rule for the given IP, action, and protocol exists."""
    os_type = platform.system()
    try:
        if os_type == "Windows":
            command = f'netsh advfirewall firewall show rule name=all | findstr /I "{ip}"'
            result = subprocess.check_output(command, shell=True, text=True)

            lines = result.lower().splitlines()
            for i in range(0, len(lines), 2):
                rule_line = lines[i].strip()
                ip_line = lines[i + 1].strip() if i + 1 < len(lines) else ""
                if action.lower() in rule_line and ip in ip_line:
                    if protocol.lower() == "any" or protocol in rule_line:
                        return True
        else:
            raise NotImplementedError("Unsupported operating system.")
    except subprocess.CalledProcessError:
        return False
    return False


def block_ip(ip_or_range, protocol="any", port=None):
    """Block a specific IP or range using firewall rules."""
    try:
        expanded_ips = expand_ip_range(ip_or_range)
        for ip in expanded_ips:
            os_type = platform.system()
            port_part = f" localport={port}" if port and os_type == "Windows" else ""

            if rule_exists(ip, "block", protocol):
                log_action("block", ip, protocol, "skipped", "IP already blocked")
                continue

            if rule_exists(ip, "allow", protocol):
                log_action("block", ip, protocol, "removing existing allow")
                remove_rule(ip, "allow", protocol)

            if os_type == "Windows":
                command = f'netsh advfirewall firewall add rule name="Block {ip} {protocol}" dir=in action=block remoteip={ip} protocol={protocol}{port_part}'
            elif os_type == "Linux":
                command = f'sudo iptables -A INPUT -s {ip} -p {protocol}{" --dport " + port if port else ""} -j DROP'
            else:
                raise NotImplementedError("Unsupported operating system.")

            os.system(command)
            log_action("block", ip, protocol, "success", f"Port: {port or 'any'}")
    except Exception as e:
        log_action("block", ip_or_range, protocol, "error", str(e))


def allow_ip(ip_or_range, protocol="any", port=None):
    """Allow a specific IP or range using firewall rules."""
    try:
        expanded_ips = expand_ip_range(ip_or_range)
        for ip in expanded_ips:
            os_type = platform.system()
            port_part = f" localport={port}" if port and os_type == "Windows" else ""

            if rule_exists(ip, "allow", protocol):
                log_action("allow", ip, protocol, "skipped", "IP already allowed")
                continue

            if rule_exists(ip, "block", protocol):
                log_action("allow", ip, protocol, "removing existing block")
                remove_rule(ip, "block", protocol)

            if os_type == "Windows":
                command = f'netsh advfirewall firewall add rule name="Allow {ip} {protocol}" dir=in action=allow remoteip={ip} protocol={protocol}{port_part}'
            elif os_type == "Linux":
                command = f'sudo iptables -A INPUT -s {ip} -p {protocol}{" --dport " + port if port else ""} -j ACCEPT'
            else:
                raise NotImplementedError("Unsupported operating system.")

            os.system(command)
            log_action("allow", ip, protocol, "success", f"Port: {port or 'any'}")
    except Exception as e:
        log_action("allow", ip_or_range, protocol, "error", str(e))


def remove_rule(ip, action, protocol="any"):
    """Remove specific firewall rules for an IP and protocol, including duplicates."""
    try:
        os_type = platform.system()
        if os_type == "Windows":
            command_list = f'netsh advfirewall firewall show rule name=all | findstr /I "{ip}"'
            result = subprocess.check_output(command_list, shell=True, text=True)
            lines = result.lower().splitlines()

            removed_count = 0
            for i in range(0, len(lines), 2):
                rule_line = lines[i].strip()
                ip_line = lines[i + 1].strip() if i + 1 < len(lines) else ""
                if action.lower() in rule_line and ip in ip_line:
                    if protocol.lower() == "any" or protocol in rule_line:
                        rule_name = rule_line.split(":")[1].strip()
                        delete_command = f'netsh advfirewall firewall delete rule name="{rule_name}"'
                        os.system(delete_command)
                        removed_count += 1
            log_action("remove", ip, protocol, "success", f"Removed {removed_count} rules")
        elif os_type == "Linux":
            # Add Linux removal logic here
            pass
        else:
            raise NotImplementedError("Unsupported operating system.")
    except Exception as e:
        log_action("remove", ip, protocol, "error", str(e))
        
def expand_ip_range(ip_or_range):
    """
    Expand an IP range in CIDR format into individual IPs. If a single IP is provided, return it as a list.
    """
    try:
        # Check if the input is a single IP
        ip = ipaddress.ip_address(ip_or_range)
        return [str(ip)]
    except ValueError:
        try:
            # Check if the input is a CIDR range
            network = ipaddress.ip_network(ip_or_range, strict=False)
            return [str(ip) for ip in network]
        except ValueError:
            raise ValueError(f"Invalid IP or range: {ip_or_range}")    

